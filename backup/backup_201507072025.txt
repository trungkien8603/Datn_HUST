#include <WiFi.h>
#include <Firebase_ESP_Client.h>
#include <ArduinoJson.h>
#include <HTTPClient.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"
#include "driver/timer.h"
#include <math.h>
#include "soc/timer_group_struct.h"
#include "soc/timer_group_reg.h"
#include <DFRobot_MAX30102.h>
#include <PubSubClient.h>
#include<Arduino.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include <HTTPUpdate.h>

#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"


BLEServer* pServer = nullptr;
BLECharacteristic* pCharacteristic = nullptr;

const char* serviceUUID = "12345678-1234-5678-1234-56789abcdef0";
const char* charUUID    = "abcdef01-1234-5678-1234-56789abcdef0";

// Th√¥ng s·ªë c·∫£m bi·∫øn MPU6050
#define FALL_THRESHOLD 5.0   // Ng∆∞·ª°ng r∆°i t·ª± do (m/s^2)
#define ANGLE_THRESHOLD 60.0 // Ng∆∞·ª°ng g√≥c nghi√™ng (ƒë·ªô)

// Ch√¢n tr·∫°ng th√°i pin
#define ANALOG_PIN 34 // Ch√¢n analog ƒë·ªÉ ƒë·ªçc dung l∆∞·ª£ng pin
#define STATUS_PIN 16 // Ch√¢n LED tr·∫°ng th√°i pin


// T·∫°o EventGroup
EventGroupHandle_t taskDone;
// ƒê·ªãnh nghƒ©a c√°c bit
#define TASK_WIFI_BIT (1 << 0)  // 0x01
#define TASK_MEASURESENSOR_BIT (1 << 1)  // 0x02
#define TASK_SEND_DATA_BIT (1 << 2)  // 0x04
#define ALL_TASKS_DONE (TASK_WIFI_BIT | TASK_MEASURESENSOR_BIT | TASK_SEND_DATA_BIT)
#define WAKE_UP_SIGNAL       (1 << 3)


#define INTERRUPT_PIN 4  // Ch√¢n ng·∫Øt b·∫•t k·ª≥
#define buzzerPinInterupt 17 // Ch√¢n ng·∫Øt ph√°t √¢m thanh


// ======= MQTT config =======
const char* mqtt_server = "192.168.1.35"; // ƒê·ªãa ch·ªâ m√°y ch·ªß MQTT
const int mqtt_port = 1883; 
const char* mqtt_topic = "health_data";


bool wifiConnected = false;
bool bleStarted = false;
String receivedSSID = "";
String receivedPASS = "";
bool credentialsReady = false;

float acc, angle_x = 0, angle_y = 0; // G√≥c t·ª´ gyro
float accel_roll = 0, accel_pitch = 0; // G√≥c t·ª´ accelerometer
float angleY_t = 0, angleX_t = 0; // G√≥c t·ª´ accelerometer
float dt = 0.5;
volatile int fallStatus = 0; // Tr·∫°ng th√°i ng√£ (true n·∫øu ng√£, false n·∫øu kh√¥ng ng√£)
float G_x2, G_y2, G_z2; // Bi·∫øn l∆∞u tr·ªØ gi√° tr·ªã gia t·ªëc t·ª´ c·∫£m bi·∫øn MPU6050


const int pwmPin = 18;      // Ch√¢n xu·∫•t PWM
const int freq = 2700;     // T·∫ßn s·ªë 1kHz
const int pwmChannel = 0;  // K√™nh PWM (0-15)
const int resolution = 8;  // ƒê·ªô ph√¢n gi·∫£i 8 bit (0-255)


int8_t SPO2Valid; //Flag to display if SPO2 calculation is valid
int8_t heartRateValid; //Flag to display if heart-rate calculation is valid 


typedef struct {
    int32_t SPO2; //SPO2
    int32_t heartRate; //Heart-rate
  } SensorData;
SensorData data; // Bi·∫øn ƒë·ªÉ l∆∞u d·ªØ li·ªáu c·∫£m bi·∫øn
// C·∫£m bi·∫øn MPU6050
Adafruit_MPU6050 mpu;
DFRobot_MAX30102 particleSensor; // C·∫£m bi·∫øn MAX30102


// ======= Clients =======
WiFiClient espClient;
PubSubClient mqttClient(espClient);

// Timer c·∫•u h√¨nh
hw_timer_t *timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;
// Bi·∫øn d√πng ƒë·ªÉ b√°o task th·ª±c thi
volatile bool doTask = false;

// Queue ƒë·ªÉ truy·ªÅn tr·∫°ng th√°i ng√£
QueueHandle_t fallQueue, dataQueue = xQueueCreate(1, sizeof(SensorData));;
SemaphoreHandle_t interruptSemaphore, buzzerSemaphore,timerSemaphore, wifiSemaphore,sendmqttMutex; // Semaphore ƒë·ªÉ ƒë·ªìng b·ªô h√≥a gi·ªØa c√°c task



#define WAKEUP_TIMER_MS 30  // v√≠ d·ª•: 30 gi√¢y
#define TIME_TO_SLEEP_US WAKEUP_TIMER_MS * 1000000ULL // 30 gi√¢y


bool sensorState = true;       // true = c·∫£m bi·∫øn ƒëang b·∫≠t
bool sleepByButton = false;    // true n·∫øu sleep l√† do nh·∫•n n√∫t
// WiFi & Firebase
// #define WIFI_SSID "Tang 3"
// #define WIFI_PASSWORD "iloveyou"
// #define FIREBASE_SECRET "IurUT7cyMoKG4ZPQj16iZuZLRFQuyoXGfZDY1ywa"
// #define FIREBASE_HOST  "firstproject-f55ec-default-rtdb.asia-southeast1.firebasedatabase.app"
// bool http_initialized = false; // Bi·∫øn ki·ªÉm tra tr·∫°ng th√°i HTTP
// WiFiUDP ntpUDP;
// NTPClient timeClient(ntpUDP, "pool.ntp.org", 3600, 60000); // C·∫≠p nh·∫≠t m·ªói ph√∫t
// const String serverURL = "https://datn-kientrung.onrender.com/esp-data";  // Flask server URL
// HTTPClient http; // ƒê·ªëi t∆∞·ª£ng HTTPClient ƒë·ªÉ g·ª≠i d·ªØ li·ªáu ƒë·∫øn Firebase

// Khai b√°o handle ƒë·ªÉ qu·∫£n l√Ω c√°c task
TaskHandle_t wifiTaskHandle = NULL;
TaskHandle_t detectFallTaskHandle = NULL;
TaskHandle_t sendDataTaskHandle = NULL;
TaskHandle_t measureHeartSpo2TaskHandle = NULL;
TaskHandle_t sleepTaskHandle = NULL;

void detectFallTask(void *parameter);
void sendDataTask(void *parameter);
void measureHeart_Spo2(void *parameter);
void stopWarning(void *parameter);
void wifiTask(void* pvParameters);
void powerTask(void* pvParameters);
// void sleepTask(void* pvParameters);


void IRAM_ATTR handleInterrupt_mpu6050() {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
            xSemaphoreGiveFromISR(interruptSemaphore, NULL);
    
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken); // Cho ph√©p chuy·ªÉn context ngay
}
void IRAM_ATTR handleInterrupt_buzzer() {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
            xSemaphoreGiveFromISR(buzzerSemaphore, NULL); // G·ªçi semaphore ƒë·ªÉ ph√°t √¢m thanh 
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken); // Cho ph√©p chuy·ªÉn context ngay
}




float statuspin() {
    int analogValue = analogRead(ANALOG_PIN); // ƒê·ªçc gi√° tr·ªã t·ª´ ch√¢n analog
    float batteryVoltage = (analogValue - 2812) / 9.51;
    // Tr·∫£ v·ªÅ tr·∫°ng th√°i c·ªßa ch√¢n pin
    return batteryVoltage; // Tr·∫£ v·ªÅ gi√° tr·ªã ƒë√£ chuy·ªÉn ƒë·ªïi
  }
// ham tat am thanh
void stopBuzzer() {
    ledcWrite(pwmChannel, 0);        // T·∫Øt xung
    ledcDetachPin(pwmPin);           // G·ª° PWM kh·ªèi ch√¢n
    pinMode(pwmPin, OUTPUT);
    digitalWrite(pwmPin, LOW);       // ƒê∆∞a ch√¢n v·ªÅ LOW ƒë·ªÉ ti·∫øt ki·ªám pin
  }
//ham bat am thanh
 void startBuzzer(uint32_t duty) {
    ledcAttachPin(pwmPin, pwmChannel);            // G·∫Øn l·∫°i ch√¢n v√†o PWM
    ledcWrite(pwmChannel, duty);                  // B·∫≠t l·∫°i v·ªõi duty mong mu·ªën
  }

  // ISR: ng·∫Øt m·ªói 25 gi√¢y
void IRAM_ATTR onTimer() {
  BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  xSemaphoreGiveFromISR(timerSemaphore, &xHigherPriorityTaskWoken);
  if (xHigherPriorityTaskWoken) {
    portYIELD_FROM_ISR();
  }
}
// init timer
void timerSetup(int interval) {
 // T·∫°o semaphore nh·ªã ph√¢n
  timerSemaphore = xSemaphoreCreateBinary();

  // T·∫°o timer: timer 0, prescaler 80 ‚Üí tick = 1us
  timer = timerBegin(0, 80, true);  // true = count up

  // G·∫Øn h√†m ng·∫Øt
  timerAttachInterrupt(timer, &onTimer, true);

  // ƒê·∫∑t th·ªùi gian ng·∫Øt m·ªói 25 gi√¢y = 25.000.000 micro gi√¢y
  timerAlarmWrite(timer, interval, true);
  timerAlarmEnable(timer);
}

class MyServerCallbacks : public BLEServerCallbacks {
  void onConnect(BLEServer* pServer) override {
    Serial.println("[BLE] Client connected");
    startBuzzer(126); // Buzzer k√™u khi c√≥ k·∫øt n·ªëi
    delay(100);
    stopBuzzer(); // T·∫Øt √¢m thanh
  }

  void onDisconnect(BLEServer* pServer) override {
    Serial.println("[BLE] Client disconnected");
  }
};

class MyCharacteristicCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic* pChar) override {
    String value = String(pChar->getValue().c_str());
    Serial.print("[BLE] Data received: ");
    Serial.println(value);

    int ssidStart = value.indexOf("SSID:") + 5;
    int ssidEnd = value.indexOf(";PASS:");
    int passStart = value.indexOf("PASS:") + 5;

    if (ssidStart > 4 && ssidEnd > ssidStart && passStart > 4) {
      receivedSSID = value.substring(ssidStart, ssidEnd);
      receivedPASS = value.substring(passStart);
      credentialsReady = true;
      Serial.println("[BLE] Credentials stored. WiFi task will handle connection.");
    } else {
      Serial.println("[BLE] Invalid format");
      pChar->setValue("INVALID");
      pChar->notify();
    }
  }
};

// ==== BLE FUNCTIONS ====

void startBLE() {
  if (bleStarted) return;
  Serial.println("[BLE] Starting BLE...");

  BLEDevice::init("ESP32-BLE-WiFi");
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());

  BLEService* pService = pServer->createService(serviceUUID);
  pCharacteristic = pService->createCharacteristic(charUUID,
      BLECharacteristic::PROPERTY_WRITE | BLECharacteristic::PROPERTY_NOTIFY);
  pCharacteristic->addDescriptor(new BLE2902());
  pCharacteristic->setCallbacks(new MyCharacteristicCallbacks());

  pService->start();
  BLEDevice::getAdvertising()->start();
  bleStarted = true;
}

void stopBLE() {
  if (!bleStarted) return;
  Serial.println("[BLE] Stopping BLE...");
  BLEDevice::getAdvertising()->stop();
  pServer->disconnect(0);  // Disconnect client
  bleStarted = false;
}




  // ham ket noi wifi
// void connectToWiFi() {
//     WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
//     while (WiFi.status() != WL_CONNECTED) {
//         delay(500);
//         Serial.print(".");
//     }
//     Serial.println("WiFi connected");
// }

// ====== MQTT ======
void connectToMQTT() {
    Serial.print("K·∫øt n·ªëi MQTT...");
    while (!mqttClient.connected()) {
      if (mqttClient.connect("ESP32_Client")) {
        Serial.println("‚úÖ MQTT ƒë√£ k·∫øt n·ªëi!");
      } else {
        Serial.print("‚ùå L·ªói MQTT, m√£ l·ªói: ");
        Serial.print(mqttClient.state());
        Serial.println(". Th·ª≠ l·∫°i sau 2s...");
        delay(2000);
      }
    }
  }

  // ====== HTTP POST fall_detect ======
// void sendFallData(int fall_detect) {
//     // if (WiFi.status() == WL_CONNECTED) {
//       HTTPClient http;
//       http.begin(serverURL);
//       http.addHeader("Content-Type", "application/json");
  
//    String payload = String("{\"fall_detect\": ") + String(fall_detect ? 1 : 0) + "}";

//       int httpResponseCode = http.POST(payload);
  
//       if (httpResponseCode > 0) {
//         Serial.print("‚úÖ HTTP Response: ");
//         Serial.println(http.getString());
//       } else {
//         Serial.print("‚ùå HTTP Error: ");
//         Serial.println(httpResponseCode);
//       }
//       http.end();
//     // } else {
//     //   Serial.println("‚ùå M·∫•t WiFi, kh√¥ng g·ª≠i ƒë∆∞·ª£c HTTP.");
//     // }
//   }

  // ====== MQTT publish ======
  void sendMQTTData(int spo2, int heartRate, int fallStatus) {
    if (mqttClient.connected()) {
      String payload = "{\"spo2\": " + String(spo2) +
                       ", \"heartRate\": " + String(heartRate) +
                       ", \"fallStatus\": " + String(fallStatus) + "}";
  
      bool sent = mqttClient.publish(mqtt_topic, payload.c_str());
      Serial.println(sent ? "‚úÖ MQTT OK" : "‚ùå MQTT FAIL");
      Serial.println("Payload: " + payload);
    } else {
      Serial.println("‚ùå MQTT not connected");
    }
  }

//   void sendMQTTData_test(float acc, float angle_x, float angle_y, float angle_z) {
//   if (mqttClient.connected()) {
//     String payload = "{\"acc\": " + String(acc, 2) + 
//                      ", \"G_x2\": " + String(G_x2, 2) + 
//                      ", \"G_y2\": " + String(G_y2, 2) +
//                      ", \"G_z2\": " + String(G_y2, 2) + "}";

//     bool sent = mqttClient.publish(mqtt_topic, payload.c_str());
//     Serial.println(sent ? "‚úÖ MQTT OK" : "‚ùå MQTT FAIL");
//     Serial.println("Payload: " + payload);
//   } else {
//     Serial.println("‚ùå MQTT not connected");
//   }
// }

void initMax30102(bool enable){
    if(enable) {
     
        particleSensor.wakeUp();     
    } else {
        // T·∫Øt c·∫£m bi·∫øn: t·∫Øt LED ƒë·ªÉ ti·∫øt ki·ªám nƒÉng l∆∞·ª£ng
        particleSensor.shutDown();  // g·ªçi h√†m shutDown n·∫øu th∆∞ vi·ªán h·ªó tr·ª£
        Serial.println("MAX30102 Disabled (Shutdown mode)");
    }
}


//cam bien mpu6050
void initMPU6050(bool enable){
    if(enable) {
        // B·∫≠t v√† kh·ªüi t·∫°o MPU6050
        if (!mpu.begin()) {
            Serial.println("Failed to find MPU6050 chip");
            while (1) { delay(10); }
        }
        Serial.println("MPU6050 Found!");
        // C·∫•u h√¨nh c·∫£m bi·∫øn khi b·∫≠t
        mpu.setHighPassFilter(MPU6050_HIGHPASS_0_63_HZ);
        mpu.setMotionDetectionThreshold(50); // 25 LSB = 0.25g
        mpu.setMotionDetectionDuration(50);
        mpu.setInterruptPinLatch(true);
        mpu.setInterruptPinPolarity(true);
        mpu.setMotionInterrupt(true);
        mpu.enableSleep(false);               // B·∫≠t c·∫£m bi·∫øn (kh√¥ng cho sleep)
        mpu.setClock(MPU6050_PLL_GYROX);
        mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
        mpu.setGyroRange(MPU6050_RANGE_500_DEG);
    } else {
        // T·∫Øt c·∫£m bi·∫øn b·∫±ng c√°ch cho sleep mode
        mpu.enableSleep(true);
        Serial.println("MPU6050 Disabled (Sleep Mode Enabled)");
    }
}

void setup() {

  Serial.begin(115200);
  
  
  
  // timerSetup(25000000); // Kh·ªüi ng·∫Øt timer
  taskDone = xEventGroupCreate(); // T·∫°o EventGroup ƒë·ªÉ qu·∫£n l√Ω task
  // ƒê·∫∑t ch·∫ø ƒë·ªô WiFi l√† STA (Station)
  WiFi.mode(WIFI_STA);
  WiFi.setSleep(true); // B·∫≠t ch·∫ø ƒë·ªô sleep ƒë·ªÉ ti·∫øt ki·ªám nƒÉng l∆∞·ª£ng
  pinMode(STATUS_PIN,OUTPUT);
   mqttClient.setServer(mqtt_server, mqtt_port);
   // C·∫•u h√¨nh ch√¢n GPIO ƒë·ªÉ l√†m ng·∫Øt ƒë√°nh th·ª©c 
  pinMode(INTERRUPT_PIN, INPUT_PULLUP);
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_4, 0);
 
    // C·∫•u h√¨nh RTC timer wake-up
  esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP_US);
        // Kh·ªüi t·∫°o PWM
        ledcSetup(pwmChannel, freq, resolution);
        ledcAttachPin(pwmPin, pwmChannel);
        ledcWrite(pwmChannel, 0);  
          startBuzzer(126); 
          delay(300);
          stopBuzzer();
  // KH√îNG x√≥a th√¥ng tin m·∫°ng c≈©
  WiFi.begin();  // T·ª± ƒë·ªông k·∫øt n·ªëi l·∫°i v·ªõi WiFi ƒë√£ l∆∞u

  Serial.println("[WiFi] ƒêang th·ª≠ k·∫øt n·ªëi WiFi ƒë√£ l∆∞u...");

  unsigned long startAttempt = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - startAttempt < 5000) {
    delay(500);
    Serial.print(".");
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n[WiFi] ƒê√£ k·∫øt n·ªëi th√†nh c√¥ng!");
    Serial.print("[WiFi] IP: "); Serial.println(WiFi.localIP());
    startBuzzer(126); // Buzzer k√™u khi k·∫øt n·ªëi th√†nh c√¥ng
    delay(500);
    stopBuzzer(); // T·∫Øt √¢m thanh
    wifiConnected = true;
    connectToMQTT(); // K·∫øt n·ªëi MQTT ngay n·∫øu ƒë√£ c√≥ WiFi
     
   
  } else {
    startBuzzer(126); // Buzzer k√™u khi kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c
    delay(300);
    stopBuzzer(); // T·∫Øt √¢m thanh
     delay(300);
    startBuzzer(126); // Buzzer k√™u khi kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c
    delay(300);
    stopBuzzer(); // T·∫Øt √¢m thanh
     delay(300);
     startBuzzer(126); // Buzzer k√™u khi kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c
    delay(300);
    stopBuzzer(); // T·∫Øt √¢m thanh

    Serial.println("\n[WiFi] K·∫øt n·ªëi th·∫•t b·∫°i. B·∫≠t BLE ƒë·ªÉ nh·∫≠n c·∫•u h√¨nh m·ªõi...");
    startBLE(); // B·∫≠t BLE n·∫øu k·∫øt n·ªëi th·∫•t b·∫°i
  }



  // K·∫øt n·ªëi Firebase

//  // K·∫øt n·ªëi Firebase
//     String url = "https://" FIREBASE_HOST "/users/kien.json?auth=" FIREBASE_SECRET;
//      http_initialized =  http.begin(url);
//     http.addHeader("Content-Type", "application/json");

    sendmqttMutex = xSemaphoreCreateMutex();
      if (sendmqttMutex == NULL) {
    Serial.println("Kh√¥ng t·∫°o ƒë∆∞·ª£c sendmqttMutex!");
        } 


    fallQueue = xQueueCreate(5, sizeof(int));// T·∫°o queue cho tr·∫°ng th√°i ng√£
    interruptSemaphore = xSemaphoreCreateBinary();// t·∫°o ngat cho mpu6050
    buzzerSemaphore = xSemaphoreCreateBinary(); // T·∫°o semaphore cho buzzer
    wifiSemaphore = xSemaphoreCreateBinary();   // T·∫°o semaphore cho WiFi

    // C·∫•u h√¨nh ng·∫Øt ngo√†i
    pinMode(INTERRUPT_PIN, INPUT_PULLUP);
    attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN), handleInterrupt_mpu6050, FALLING);
    pinMode(buzzerPinInterupt, INPUT_PULLDOWN); 
    attachInterrupt(digitalPinToInterrupt(buzzerPinInterupt), handleInterrupt_buzzer, RISING); // Ng·∫Øt cho buzzer


    
    // T·∫°o Task
  xTaskCreate(wifiTask, "WiFi Task", 8192, NULL, 2, &wifiTaskHandle);
  xTaskCreate(detectFallTask, "Detect Fall", 4096, NULL, 5, &detectFallTaskHandle);
  xTaskCreate(sendDataTask, "Send Data", 4096, NULL, 2, &sendDataTaskHandle);
  xTaskCreate(measureHeart_Spo2, "Measure Fall", 4096, NULL, 4, &measureHeartSpo2TaskHandle);
  xTaskCreate(stopWarning, "Stop Warning", 4096, NULL, 5, NULL);
  // xTaskCreate(sleepTask, "Sleep Task", 2048, NULL, 2, &sleepTaskHandle);
  xTaskCreate(powerTask, "Power Task", 2048, NULL, 1, NULL);
}

void loop() {
    vTaskDelete(NULL);
}
// ==== Task Power ====
void powerTask(void* pvParameters) {
  while (true) {
    if (statuspin() <= 20) {
      digitalWrite(STATUS_PIN, HIGH); // B·∫≠t ƒë√®n LED n·∫øu pin y·∫øu
    } else {
      digitalWrite(STATUS_PIN, LOW); // T·∫Øt ƒë√®n LED n·∫øu pin ƒë·ªß
    }
    vTaskDelay(pdMS_TO_TICKS(60000)); // Ki·ªÉm tra m·ªói 60 gi√¢y
  }
}

// ==== Task WiFi ====
void wifiTask(void* pvParameters) {   
  int retryCount = 0;
  int reconnectAttempts = 0; // ƒê·∫øm s·ªë l·∫ßn th·ª≠ k·∫øt n·ªëi l·∫°i li√™n ti·∫øp
  bool wasConnected = false; // Theo d√µi tr·∫°ng th√°i k·∫øt n·ªëi tr∆∞·ªõc ƒë√≥
  
  printf("dang thuc hien task kiem tra wifi...\n");   
  
  while (true) {     
    bool forceReconnect = false;     
    if (xSemaphoreTake(wifiSemaphore, 0) == pdTRUE) {   
      forceReconnect = true;       
    }     
    
    // K·∫øt n·ªëi WiFi l·∫ßn ƒë·∫ßu ho·∫∑c khi c√≥ th√¥ng tin m·ªõi
    if (credentialsReady || forceReconnect) {       
      WiFi.begin(receivedSSID.c_str(), receivedPASS.c_str());       
      vTaskDelay(pdMS_TO_TICKS(1000));       
      Serial.printf("[WiFi] Connecting to: %s\n", receivedSSID.c_str());        
      
      unsigned long startAttempt = millis();       
      while (WiFi.status() != WL_CONNECTED && millis() - startAttempt < 15000) {         
        delay(500);         
        Serial.print(".");       
      }        
      
      if (WiFi.status() == WL_CONNECTED) {         
        Serial.print("\n[WiFi] Connected. IP: ");         
        Serial.println(WiFi.localIP());         
        wifiConnected = true;         
        credentialsReady = false;         
        wasConnected = true;
        reconnectAttempts = 0; // Reset counter khi k·∫øt n·ªëi th√†nh c√¥ng
        
        startBuzzer(126);         
        delay(500);         
        stopBuzzer();                   
        
        pCharacteristic->setValue("WIFI_OK");         
        pCharacteristic->notify();                   
        stopBLE();                               
      } else {         
        Serial.println("\n[WiFi] Failed");         
        pCharacteristic->setValue("WIFI_FAIL");         
        pCharacteristic->notify();         
        credentialsReady = false;         
        wifiConnected = false;         
        
        // Buzzer pattern cho l·ªói k·∫øt n·ªëi
        for(int i = 0; i < 3; i++) {
          startBuzzer(126);         
          delay(300);         
          stopBuzzer();         
          delay(300);
        }
      }     
    }      
    
    // Ki·ªÉm tra tr·∫°ng th√°i WiFi ƒë·ªãnh k·ª≥
    if (WiFi.status() != WL_CONNECTED) {       
      if (wasConnected) { // Ch·ªâ ƒë·∫øm khi tr∆∞·ªõc ƒë√≥ ƒë√£ k·∫øt n·ªëi (m·∫•t k·∫øt n·ªëi)
        reconnectAttempts++;
        Serial.printf("[WiFi] Connection lost. Attempt %d/3 to reconnect...\n", reconnectAttempts);
        
        // Th·ª≠ k·∫øt n·ªëi l·∫°i v·ªõi th√¥ng tin ƒë√£ l∆∞u
        if (reconnectAttempts <= 3) {
          WiFi.begin(receivedSSID.c_str(), receivedPASS.c_str());
          vTaskDelay(pdMS_TO_TICKS(1000));
          
          unsigned long startAttempt = millis();
          while (WiFi.status() != WL_CONNECTED && millis() - startAttempt < 10000) {
            delay(500);
            Serial.print(".");
          }
          
          if (WiFi.status() == WL_CONNECTED) {
            Serial.println("\n[WiFi] Reconnected successfully!");
            wifiConnected = true;
            reconnectAttempts = 0; // Reset khi k·∫øt n·ªëi l·∫°i th√†nh c√¥ng
            
            startBuzzer(126);
            delay(500);
            stopBuzzer();
          } else {
            Serial.printf("\n[WiFi] Reconnect attempt %d failed\n", reconnectAttempts);
            wifiConnected = false;
            
            // Buzzer pattern cho th·∫•t b·∫°i
            for(int i = 0; i < 2; i++) {
              startBuzzer(126);
              delay(200);
              stopBuzzer();
              delay(200);
            }
          }
        }
        
        // Sau 3 l·∫ßn th·ª≠ kh√¥ng th√†nh c√¥ng -> b·∫≠t BLE
        if (reconnectAttempts >= 3 && !wifiConnected) {
          Serial.println("[WiFi] Failed to reconnect after 3 attempts. Re-enabling BLE...");
          wasConnected = false; // ƒê√°nh d·∫•u kh√¥ng c√≤n trong tr·∫°ng th√°i "ƒë√£ k·∫øt n·ªëi"
          reconnectAttempts = 0; // Reset counter
          startBLE();
          
          // Buzzer pattern ƒë·∫∑c bi·ªát cho vi·ªác chuy·ªÉn sang BLE
          for(int i = 0; i < 3; i++) {
            startBuzzer(126);
            delay(300);
            stopBuzzer();
            delay(300);
          }
        }
      }
    } else {       
      // WiFi ƒë√£ k·∫øt n·ªëi
      if (!wifiConnected) { // V·ª´a m·ªõi k·∫øt n·ªëi l·∫°i
        Serial.println("[WiFi] Connection restored!");
        wifiConnected = true;
        wasConnected = true;
        reconnectAttempts = 0;
        
        startBuzzer(126);
        delay(500);
        stopBuzzer();
      }
    }

    vTaskDelay(pdMS_TO_TICKS(10000)); // Ki·ªÉm tra m·ªói 22 gi√¢y
    xEventGroupSetBits(taskDone, TASK_WIFI_BIT);
  }
}
// Task 4: ƒêo nh·ªãp tim v√† SPO2

void measureHeart_Spo2(void *parameter) {
    while (1) {
       printf("ƒêang ƒëo SPO2 v√† nh·ªãp tim...\n");
            particleSensor.heartrateAndOxygenSaturation(/**SPO2=*/&data.SPO2, /**SPO2Valid=*/&SPO2Valid, /**heartRate=*/&data.heartRate, /**heartRateValid=*/&heartRateValid);
            xQueueOverwrite(dataQueue, &data); // G·ª≠i d·ªØ li·ªáu v√†o queue
           vTaskDelay(pdMS_TO_TICKS(1500)); // ƒê·ª£i 500ms tr∆∞·ªõc khi ƒëo l·∫°i
        
         xEventGroupSetBits(taskDone, TASK_MEASURESENSOR_BIT);

    }
  }

// Task 1: Ph√°t hi·ªán ng√£
void detectFallTask(void *parameter) {
    while (1) {
        // Ch·ªù ng·∫Øt ƒë·ªÉ b·∫Øt ƒë·∫ßu x·ª≠ l√Ω
        if (xSemaphoreTake(interruptSemaphore, portMAX_DELAY) == pdTRUE) {
         
            // Th·ª±c hi·ªán x·ª≠ l√Ω sau khi c√≥ ng·∫Øt
            sensors_event_t a, g, t;
            mpu.getEvent(&a, &g, &t);

            float ax = a.acceleration.x;
            float ay = a.acceleration.y;
            float az = a.acceleration.z;
            G_x2 = g.gyro.x;
            G_y2 = g.gyro.y;
            G_z2 = g.gyro.z;

            acc = sqrt(ax * ax + ay * ay + az * az);

            // accel_roll = atan2(ay, sqrt(ax * ax + az * az)) * 180 / PI;
            // accel_pitch = atan2(-ax, sqrt(ay * ay + az * az)) * 180 / PI;



            // angleX_t = atan2(ax, sqrt(ay * ay + az * az)) * 180.0 / PI;
            // angleY_t = atan2(ay, sqrt(ax * ax + az * az)) * 180.0 / PI;

            // vTaskDelay(pdMS_TO_TICKS(200)); // Gi·ªØ task l·∫°i m·ªôt ch√∫t tr∆∞·ªõc khi ƒëo l·∫ßn 2

            // // ƒêo l·∫ßn 2
            // sensors_event_t a_2, g_2;
            // mpu.getEvent(&a_2, &g_2, &t);
            // mpu.getMotionInterruptStatus(); // ƒê·ªçc tr·∫°ng th√°i ng·∫Øt chuy·ªÉn ƒë·ªông( m·ª•c ƒë√≠ch ƒë·ªÉ x√≥a c·ªù ng·∫Øt)

            // float ax2 = a_2.acceleration.x;
            // float ay2 = a_2.acceleration.y;
            // float az2 = a_2.acceleration.z;

            // acc = sqrt(ax2 * ax2 + ay2 * ay2 + az2 * az2);
            // accel_roll = atan2(ay2, sqrt(ax2 * ax2 + az2 * az2)) * 180 / PI; //don vi ra ƒë·ªô
            // accel_pitch = atan2(-ax2, sqrt(ay2 * ay2 + az2 * az2)) * 180 / PI;

            //  G_x2 = g_2.gyro.x ;
            //  G_y2 = g_2.gyro.y ;

            // float angleX_s = angleX_t + G_x2 * dt;
            // float angleY_s = angleY_t + G_y2 * dt;
                Serial.print("\ngyro_x: ");
                Serial.print(G_x2, 2);  
                Serial.print(" \ngyro_y: ");
                Serial.print(G_y2, 2);
                Serial.print("\ngyro_z: ");
                Serial.print(G_z2, 2);
            // angle_x = 0.98 * angleX_s + 0.02 * accel_roll;
            // angle_y = 0.98 * angleY_s + 0.02 * accel_pitch;

       
            // Serial.print("acc: ");
            // Serial.print(acc, 2);
            // Serial.print(" angle_x: ");
            // Serial.print(angle_x, 2);
            // Serial.print(" angle_y: ");
            // Serial.println(angle_y, 2);
            mpu.getMotionInterruptStatus(); // ƒê·ªçc tr·∫°ng th√°i ng·∫Øt chuy·ªÉn ƒë·ªông( m·ª•c ƒë√≠ch ƒë·ªÉ x√≥a c·ªù ng·∫Øt)
            if (acc > 14.0 && (abs(G_x2) > 1.4 || abs(G_y2) > 2.0  || abs(G_z2) > 2.0)) {
                     fallStatus = 1; // Ng√£
                      if (xSemaphoreTake(sendmqttMutex, pdMS_TO_TICKS(500))) {
                          sendMQTTData(data.SPO2, data.heartRate,fallStatus);
                          xSemaphoreGive(sendmqttMutex);
                      }
                    Serial.println("Fall detected!");
                    startBuzzer(126); // Buzzer k√™u
                  
                }
            // xQueueSend(fallQueue, (const void*)&fallStatus, 0);

            // Reset tr·∫°ng th√°i ƒë·ªÉ v√≤ng l·∫∑p sau ch·ªù ng·∫Øt m·ªõi
            vTaskDelay(pdMS_TO_TICKS(50));
        }
    }
}

// Task 3: D·ª´ng ph√°t √¢m thanh c·∫£nh b√°o
void stopWarning(void *parameter) {
    while (1) {
        if (xSemaphoreTake(buzzerSemaphore, portMAX_DELAY) == pdTRUE) {
            unsigned long pressStart = millis();
            bool longPressHandled = false;
            TickType_t lastWakeTime = xTaskGetTickCount();

            while (digitalRead(buzzerPinInterupt) == HIGH) {
                if (!longPressHandled && (millis() - pressStart >= 3000)) {
                    longPressHandled = true;

                    if (sensorState) {
                        Serial.println("Gi·ªØ 3s ‚Äì T·∫Øt c·∫£m bi·∫øn v√† cho ESP32 ng·ªß (ch·ªâ wake b·∫±ng n√∫t)");

                        // Suspend tasks tr∆∞·ªõc khi t·∫Øt sensors
                        vTaskSuspend(wifiTaskHandle);
                        vTaskSuspend(sendDataTaskHandle);
                        vTaskSuspend(measureHeartSpo2TaskHandle);

                        // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ tasks ho√†n th√†nh c√¥ng vi·ªác hi·ªán t·∫°i
                        vTaskDelay(pdMS_TO_TICKS(100));

                        initMax30102(false);
                        initMPU6050(false);
               
                        Serial.println("C·∫£m bi·∫øn ƒë√£ ƒë∆∞·ª£c t·∫Øt");
                        sensorState = false;

                        sleepByButton = true;

                        startBuzzer(126); 
                        vTaskDelay(pdMS_TO_TICKS(1300));  // Thay delay() b·∫±ng vTaskDelay()
                        stopBuzzer();
                        Serial.println("Buzzer ƒë√£ k√™u...");

                    } else {
                        Serial.println("Gi·ªØ 3s ‚Äì B·∫≠t l·∫°i c·∫£m bi·∫øn");

                        initMax30102(true);
                        initMPU6050(true);
                        sensorState = true;
                        Serial.println("C·∫£m bi·∫øn ƒë√£ ƒë∆∞·ª£c b·∫≠t l·∫°i");
                        // ƒê·ª£i sensors kh·ªüi t·∫°o xong
                        vTaskDelay(pdMS_TO_TICKS(300));

                      
                        vTaskResume(wifiTaskHandle);
                        vTaskResume(sendDataTaskHandle);
                        vTaskResume(measureHeartSpo2TaskHandle);

                        startBuzzer(126); 
                        vTaskDelay(pdMS_TO_TICKS(300));  // Thay delay() b·∫±ng vTaskDelay()
                        stopBuzzer();
                    }
                }

                // S·ª≠ d·ª•ng vTaskDelayUntil ƒë·ªÉ timing ch√≠nh x√°c h∆°n
                vTaskDelayUntil(&lastWakeTime, pdMS_TO_TICKS(50));
            }

            // Khi nh·∫£ n√∫t, reset tr·∫°ng th√°i c·∫£nh b√°o
            stopBuzzer();
            fallStatus = 0;

            // Ki·ªÉm tra queue c√≥ ƒë·∫ßy kh√¥ng tr∆∞·ªõc khi g·ª≠i
            if (xQueueSend(fallQueue, (const void*)&fallStatus, pdMS_TO_TICKS(100)) != pdTRUE) {
                Serial.println("Warning: fallQueue full!");
            }
        }
    }
}
// Task 2: G·ª≠i d·ªØ li·ªáu ƒë·∫øn server
void sendDataTask(void *parameter) {
    // int fallStatus = 0; // Khai b√°o fallStatus ·ªü ƒë·∫ßu task
    
    while (1) {
        // Ki·ªÉm tra WiFi
        if (WiFi.status() != WL_CONNECTED) {
            Serial.println("‚ö†Ô∏è WiFi m·∫•t k·∫øt n·ªëi, th·ª≠ k·∫øt n·ªëi l·∫°i...");
            xSemaphoreGive(wifiSemaphore); // ƒê√°nh d·∫•u c·∫ßn k·∫øt n·ªëi l·∫°i WiFi
            vTaskDelay(pdMS_TO_TICKS(5000)); // ƒê·ª£i tr∆∞·ªõc khi th·ª≠ l·∫°i
            continue; // Quay l·∫°i ƒë·∫ßu v√≤ng l·∫∑p
        }
        
        // WiFi ƒë√£ k·∫øt n·ªëi
        if (!mqttClient.connected()) {
            connectToMQTT(); // K·∫øt n·ªëi l·∫°i n·∫øu m·∫•t k·∫øt n·ªëi
        }
        
        // Reset fallStatus tr∆∞·ªõc khi ki·ªÉm tra queue
        // fallStatus = 0;
        
        // Ki·ªÉm tra queue (kh√¥ng blocking)
        xQueueReceive(fallQueue, (void*)&fallStatus, 0);
        xQueueReceive(dataQueue, (void*)&data, 0);
        
        // G·ª≠i d·ªØ li·ªáu MQTT
        if (xSemaphoreTake(sendmqttMutex, pdMS_TO_TICKS(500))) {
          data.heartRate = -0.1021*data.heartRate + 73.58; // Chuy·ªÉn ƒë·ªïi nh·ªãp tim
          data.SPO2 = -0.0082 *data.SPO2 + 98.93; // Chuy·ªÉn ƒë·ªïi SPO2 
          if(data.SPO2 >100)  data.SPO2 = 100; // Gi·ªõi h·∫°n SPO2 t·ªëi ƒëa l√† 100
            sendMQTTData(data.SPO2, data.heartRate, fallStatus);
            xSemaphoreGive(sendmqttMutex);
        }
        
        // Set bit ho√†n th√†nh task
        xEventGroupSetBits(taskDone, TASK_SEND_DATA_BIT);
        
        // X·ª≠ l√Ω delay d·ª±a tr√™n tr·∫°ng th√°i
        if (fallStatus) {
            // N·∫øu c√≥ ng√£, delay l√¢u h∆°n v√† kh√¥ng sleep
            Serial.println("üö® Ph√°t hi·ªán ng√£! Kh√¥ng chuy·ªÉn sang ch·∫ø ƒë·ªô ng·ªß.");
            vTaskDelay(pdMS_TO_TICKS(5000));
        } else {
            // Ch·∫ø ƒë·ªô b√¨nh th∆∞·ªùng - c√≥ th·ªÉ sleep ƒë·ªÉ ti·∫øt ki·ªám pin
            Serial.println("Chu·∫©n b·ªã chuy·ªÉn sang ch·∫ø ƒë·ªô ng·ªß...");
            
            // T·∫Øt c·∫£m bi·∫øn tr∆∞·ªõc khi sleep
            // initMax30102(false);
            // sensorState = false;
            
            // Serial.println("ƒê√£ chuy·ªÉn sang ch·∫ø ƒë·ªô ng·ªß ƒë·ªÉ ti·∫øt ki·ªám nƒÉng l∆∞·ª£ng...");
            
            
            // // Th·ª©c d·∫≠y - b·∫≠t l·∫°i c·∫£m bi·∫øn
            // Serial.println("Tho√°t tr·∫°ng th√°i ng·ªß, b·∫≠t l·∫°i c·∫£m bi·∫øn...");
            // initMax30102(true);
            // sensorState = true;
            
            // Delay ng·∫Øn ƒë·ªÉ c·∫£m bi·∫øn ·ªïn ƒë·ªãnh
            vTaskDelay(pdMS_TO_TICKS(15000));
        }
    }
}
// void sleepTask(void *pv) {
//   while (1) {
//     // Ch·ªù t·∫•t c·∫£ task ho√†n th√†nh vi·ªác g·ª≠i d·ªØ li·ªáu
//     EventBits_t bits = xEventGroupWaitBits(
//       taskDone,
//       ALL_TASKS_DONE,
//       pdTRUE,        // Clear bits sau khi nh·∫≠n
//       pdTRUE,        // Ch·ªù t·∫•t c·∫£ bits (AND)
//       portMAX_DELAY  // Ch·ªù v√¥ h·∫°n
//     );

//     if ((bits & ALL_TASKS_DONE) == ALL_TASKS_DONE && fallStatus == 0 && WiFi.status() == WL_CONNECTED) {
//       Serial.println("D·ªØ li·ªáu ƒë√£ g·ª≠i xong. Chuy·ªÉn sang tr·∫°ng th√°i ng·ªß...");

//       // T·∫Øt c·∫£m bi·∫øn ƒë·ªÉ ti·∫øt ki·ªám nƒÉng l∆∞·ª£ng
//       // initMPU6050(false);
//       initMax30102(false);
//       sensorState = false;

//       esp_light_sleep_start(); // Chuy·ªÉn sang ch·∫ø ƒë·ªô ng·ªß
//       // B·∫≠t l·∫°i c·∫£m bi·∫øn
//       // initMPU6050(true);
//       initMax30102(true);
//       sensorState = true;
 
    

//       Serial.println("Tho√°t tr·∫°ng ng·ªß, ti·∫øp t·ª•c chu k·ª≥ m·ªõi...");
//         // ‚úÖ RESET cho v√≤ng m·ªõi
     
//       xEventGroupSetBits(taskDone, WAKE_UP_SIGNAL);

//       vTaskDelay(pdMS_TO_TICKS(100)); // ƒê·ª£i h·ªá th·ªëng ·ªïn ƒë·ªãnh
//     }
//   }
// }
